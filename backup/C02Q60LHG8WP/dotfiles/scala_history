exit
run
:load fpinscala.gettingstarted.MyModule
fpinscala.gettingstarted.MyModule
fpinscala.gettingstarted.MyModule.fib
fpinscala.gettingstarted.MyModule.fib(1)
fpinscala.gettingstarted.MyModule.fib(2)
fpinscala.gettingstarted.MyModule.fib(3)
fpinscala.gettingstarted.MyModule.fib(5)
fpinscala.gettingstarted.MyModule.TestFib.main(Array())
fpinscala.gettingstarted.TestFib.main(Array())
fpinscala.gettingstarted.isSorted
fpinscala.gettingstarted.PolymorphicFunctions.isSorted(Array())
fpinscala.gettingstarted.PolymorphicFunctions.isSorted(Array(), _ > _)
fpinscala.gettingstarted.PolymorphicFunctions.isSorted(Array(), (x: Int, y: Int): Boolean => x > y )
fpinscala.gettingstarted.PolymorphicFunctions.isSorted(Array(), (x: Int, y: Int) => x > y )
fpinscala.gettingstarted.PolymorphicFunctions.isSorted(Array(1), (x: Int, y: Int) => x > y )
fpinscala.gettingstarted.PolymorphicFunctions.isSorted(Array(1, 2), (x: Int, y: Int) => x > y )
fpinscala.gettingstarted.PolymorphicFunctions.isSorted(Array(1, 3,  2), (x: Int, y: Int) => x > y )
fpinscala.gettingstarted.PolymorphicFunctions.isSorted(Array(3, 2), (x: Int, y: Int) => x > y )
fpinscala.gettingstarted.PolymorphicFunctions.isSorted(Array(3, 2, 1), (x: Int, y: Int) => x > y )
exit
fpinscala.gettingstarted.PolymorphicFunctions
exit
fpinscala.datastructures.List.main(Array())
q
sys.exit
fpinscala.datastructures.List.main(Array())
sys.exit
fpinscala.datastructures.List.main(Array())
sys.exit
fpinscala.datastructures.List.main(Array())
fpinscala.datastructures.List.foldRight(List(1,2,3), Nil:List[Int])(Cons(_,_))
sys.exit
fpinscala.datastructures.List.ex8
sys.exit
fpinscala.datastructures.List.length(Cons(1))
fpinscala.datastructures.List.length(Cons(1, Nil))
fpinscala.datastructures.List.length(List)
fpinscala.datastructures.List.length(List(1,2,3))
sys.exit
fpinscala.datastructures.List.main(Array())
sys.exit
fpinscala.datastructures.List.main(Array())
sys.exit
fpinscala.datastructures.List.main(Array())
sys.exit
fpinscala.datastructures.List.main(Array())
%d".format(1.2)
"%d".format(1.2)
"%f".format(1.2)
"%0.2f".format(1.2)
"%2f".format(1.2)
"%0.2f".format(1.2)
"%1.2f".format(1.2)
"%1.2f".format(11.2)
sys.exit
fpinscala.datastructures.Tree.main
fpinscala.datastructures.Tree.main(Array())
sys.exit
fpinscala.datastructures.Tree.main(Array())
sys.exit
fpinscala.datastructures.Tree.main(Array())
sys.exit
fpinscala.datastructures.Tree.main(Array())
sys.exit
fpinscala.datastructures.Tree.main(Array())
sys.exit
fpinscala.datastructures.Tree.main(Array())
sys.exit
fpinscala.datastructures.Tree.main(Array())
sys.exit
fpinscala.datastructures.Tree.main(Array())
sys.exit
fpinscala.datastructures.Tree.main(Array())
sys.exit
fpinscala.datastructures.Tree.main(Array())
math
import math
math
math.pow
math.pow_
math.pow(`,1)
math.pow(1,1)
math.pow(1,2)
Seq
Seq(1,2,3)
sys.exit
fpinscala.errorhandling.Option.main(Array())
sys.exit
fpinscala.errorhandling.Option.main(Array())
sys.e
sys.exit
fpinscala.errorhandling.Option.main(Array())
sys.exit
fpinscala.errorhandling.Option.main(Array())
scala
scala.List
sys.exit
:load play.scala
:reset
:load
:load play.scala
:reset
:load play.scala
defA
defB
:reset
:load play.scala
:reset
:load play.scala
:reset
:load play.scala
:reset
:load play.scala
:reset
:load play.scala
:reset
:load play.scala
:reset
:load play.scala
printHello.unsafePerform
valA.unsafePerform
:reset
:load
:reset; :load play.scala
:load play.scala
:reset; :load play.scala
:load
:reset 
:load play
:load play.scala
printNum(1)
printNum(1).unsafePerform
printNum(1).map(_ + 1).unsafePerform
printNum(1).map(_ + 1).map(_ + 11)
printNum(1).map(_ + 1)
res9.unsafePerform
res8.unsafePerform
:reset
:load play.scala
printNum(1).flatMap{ printNum(_ + 1) }
printNum(1).flatMap{ i =>printNum(i + 1) }
printNum(1).flatMap{ i =>printNum(i + 1) }.unsafePeform
printNum(1).flatMap{ i =>printNum(i + 1) }.unsafePerform
for { i <- printNum(1); _ <- printNum(i) } yield ()
()
().getClass
for { i <- printNum(1); _ <- printNum(i) } yield ()
res12.unsafePerform
for { i <- printNum(1); _ <- printNum(i + 1) } yield ()
res14.unsafePerform
import scalaz.concurrent.Task
def printNum(n: Int) = Task { println(n); n }
Task.run
printNum(1).run
printNum(sys.error("no")).run
printNum(sys.error("no"))
def printNum(n: =>Int) = Task { println(n); n }
printNum(sys.error("no"))
res20.run
printNum(1))
printNum(1)
import scalaz.syntax.monad._
printNum(1) >>= printNum
def printNum(n: Int) = Task { println(n); n }
printNum(1) >>= printNum
printNum(1) >>= printNum >>= printNum
def printNum(n: =>Int) = Task { println(n); n + 1 }
printNum(1) >>= printNum >>= printNum
def printNum(n: Int) = Task { println(n); n + 1 }
printNum(1) >>= printNum >>= printNum
res27.run
import scalaz.IList
IList(1,2,3) map printNum
IList(1,2,3) map printNum sequence
IList(1,2,3).map(printNum).sequence
import scalaz.syntax.traverse._
IList(1,2,3).map(printNum).sequence
IList(1,2,3).map(printNum).sequence.run
IList(1,2,3).map(printNum).sequence_.run
IList(1,2,3).map(printNum).sequence_
import scalaz._
import Scalaz._
1.right[String]
"fail".left[Int]
IList(1.right[String], 2.right[String], 3.right[String]).sequence
IList(1.right[String], 2.right[String], 3.right[String]).sequenceU
IList(1.right[String], "fail".left[Int],, 3.right[String]).sequenceU
IList(1.right[String], "fail".left[Int], 3.right[String]).sequenceU
System.nanoTime
def time = Task { System.nanotime }
def time = Task { System.nanoTime }
time *> time *> time
res43.run
def time = Task { println(System.nanoTime) }
time *> time *> time
time *> time *> time run
IList(1.successNel[String])
(1.successNel[String] |@| 2.sucessNel)(_ + _)
(1.successNel[String] |@| 2.successNel)(_ + _)
(1.successNel[String] |@| 2.successNel |@| 3.successNel)(_ + _)
(1.successNel[String] |@| 2.successNel |@| 3.successNel)(_ + _ + _)
(1.successNel[String] |@| "fail".failNel |@| 3.successNel)(_ + _ + _)
(1.successNel[String] |@| "fail".failNel[Int] |@| 3.successNel)(_ + _ + _)
(1.successNel[String] |@| "fail".failNel[Int] |@| "fail again".failNel)(_ + _ + _)
(1.successNel[String] |@| "fail".failNel[Int] |@| "fail again".failNel[Int])(_ + _ + _)
sys.exit
fpinscala.errorhandling.Option.main(Array())
sequence(List(Some(1), Some(2), Some(3)))
fpinscala.errorhandling.Option.main(Array())
sys.exit
fpinscala.errorhandling.Option.main(Array())
sys.exit
fpinscala.errorhandling.Option.main(Array())
sys.exit
fpinscala.errorhandling.Option.main(Array())
sys.exit
fpinscala.errorhandling.Option.main(Array())
sys.exit
fpinscala.errorhandling.Option.main(Array())
sys.exit
fpinscala.errorhandling.Either.main(Array())
ture
true
true || {asdasdasdasd}
true || {println}
true || { println() }
true || { println(); true}
sys.error("failure")
true || { sys.error("failure") }
type
(sys.error("failure"))
type(sys.error("failure"))
typeof
:type sys.error("failure")
def x = 2
x
xx
val xx = 3
:type x
:type xx
laxy def x = {println(2); 2 }
lazy def x = {println(2); 2}
lazy val x = {println(2); 2}
x
lazy val x = {println(2); 2}
lazy var x = {println(2); 2}
lazy val x = {println(2); 2}
sys.exit
fpinscala.laziness.Test.main(Array())
val x = () => 2
x
x()
frg x = () => 2
def x = () => 2
var x = () => 2
x
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
def x(()=>a): = println(a)
def x( () => a : Int): = println(a)
def x( => a : Int): = println(a)
def x(a: () => Int): = println(a)
def x(a: () => Int): Unit = println(a)
x(1)
def x(a:  => Int): Unit = println(a)
x(1)
0 < 1
0 < -1
def x(h: => Int): Int = {lazy val hh = h; () => hh}
def x(h: => Int): () => Int = {lazy val hh = h; () => hh}
x(1)
x(1)()
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
false & true
sys.exit
false & true
fpinscala.laziness.Test.main(Array())
false & true
sys.exit
fpinscala.laziness.Test.main(Array())
false & { println(1); true}
 { println(1); true} & false
true ||  { println(1); true}
true |  { println(1); true}
false && { println(1); true}
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
(1,2)
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
fpinscala.laziness.Test.main(Array())
sys.exit
Int.
compile
sys.exit
Int.MinValue
Int.MaxValue
Int.MinValue
abs
Int.MinValue.abs
(Int.MinValue + 1).abs
sys.exit
fpinscala.state.Test.main(Array())
sys.exit
List
List.cons
List.Cons()
List.Cons
List.concat
List.concat(1, 2)
List.apply
List.apply(1, 2
)
::
1 :: 2
1 List.:: 2
1 :: 2
1 :: 2 :: Nil
List(1) :: 2
1 :: List()
1 :: List(1)
1 :: List(2)
sys.exit
_
_.
s
sys.exit
fpinscala.state.Test.main(Array())
sys.exit
fpinscala.state.Test.main(Array())
sys.exit
fpinscala.state.Test.main(Array())
sys.exit
import com.c12w.learn.data._
import com.c12e.learn.data._
import com.c12e.learn.typeclass.Applicative.Syntax._
1.pure[IList]
IList(1,2,3)
IList(1,2,3) <*> IList({ _ + 10 }, { _ + 20 })
IList(1,2,3) <*> IList[Int => Int]({ _ + 10 }, { _ + 20 })
import com.c12e.learn
import com.c12e.learn._
IList(1, 2, 3)
import com.c12e.learn.data._
IList(1, 2, 3)
IList(1, 2, 3).zip(IList(2,3))
~console
exit
sys.exit
exit
import com.c12e.learn.data.IList
import com.c12e.learn.typeclass.Applicative
import com.c12e.learn.typeclass.Applicative.Syntax._
IList(1,2) <*> IList({_ * 5}, {_ * 10})
IList(1,2) <*> IList({_:Int * 5}, {_:Int * 10})
IList(1,2) <*> IList({ x: Int => x * 5}, {x: Int => x * 10})
exit
import com.c12e.learn.typeclass.Applicative
IList(1,2) <*> IList({ x: Int => x * 5}, {x: Int => x * 10})
sys.exit
println(s"")
val x = 1
println(s"${x == 1 ? 1 : 2}")
println(s"${if ( x== 1) { 1 } else { 2 }")
println(s"${if ( x== 1) { 1 } else { 2 } ")
println(s"${ if ( x== 1) \{ 1 \} else \{ 2 \}")
println(s"${ if ( x== 1) \{ 1 \} else \{ 2 }")
println(s"${ if ( x== 1) { 1 } else { 2 } }")
println(s"${ if ( x== 1 ) { 12 } else { 2 } }")
println(s"${ while ( x== 1 ) { 12 }  }")
println(s"${ while ( x== 1 ) { println(12) }  }")
println(s"${ while ( x== 1 ) { 12 } }")
println(s"${ if( x == 1) { while ( x== 1 ) { 12 } } else { 1 }  }")
println(s"${ if( x == 1) { while ( x== 1 ) { 12 } 1 } else { 1 }  }")
println(s"${ if( x == 1) { while ( x== 1 ) { 12 } return 1 } else { 1 }  }")
println(s"${ if( x == 1) { while ( x== 1 ) { 12 }; return 1 } else { 1 }  }")
println(s"${ if( x == 1) { while ( x== 1 ) { 12 }; 1 } else { 1 }  }")
val x = 1
println(s"${ if( x == 1) { while ( x== 1 ) { 12 }; return 1 } else { 1 }  }")
println(s"${ if( x == 1) { while ( x== 1 ) { 12 }; 1 } else { 1 }  }")
println(s"${ if( x == 1) { while ( x== 1 ) { println(12) }; 1 } else { 1 }  }")
val x  = 1
println(s"${ if( x == 1) { while ( x== 1 ) { println(12) }; 1 } else { 1 }  }")
new java.sql.Timestamp(System.currentTimeMillis())
TimeZone tz = TimeZone.getTimeZone("UTC");
DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'");
df.setTimeZone(tz);
String nowAsISO = df.format(new Date());
exit
exit()
java.util.Optional<Double>
new java.util.Optional<Double>.of(Null)
new java.util.Optional<Double>.of(Null);
val x = new java.util.Optional<Double>.of(Null);
val x = new java.util.Optional[Double].of(Null);
val x = new java.util.Optional[Double].of(None);
val x = java.util.Optional[Double].of(None);
val x = java.util.Optional[Double]
val x = java.util.Optional[Double](None)
val x = new java.util.Optional[Double]()
val x = new java.util.Optional[Double]();
Stream(1)
Stream(1).append
Stream(1) append Stream(2)
(Stream(1) append Stream(2)).foreach
(Stream(1) append Stream(2)).foreach(println)
exit
List(1,2,3).foldLeft(0){ _ + _ }
List(1,2,3).foldLeft(0){ (x, y) => x + y }
List(1,2,3).foldLeft(0){ (x, y) => x*x + y*y }
List(1,2,3).foldLeft(0){ (x, y) => x + y*y }
Stream(1,2,3,4,5).foldLeft(([], Stream())) { case ((a, s), y) => ((y::a), y::s) }
Stream(1,2,3,4,5).foldLeft(([], Stream())){ case ((a, s), y) => ((y::a), y::s) }
Stream(1,2,3,4,5).foldLeft( (List(), Stream()) ){ case ((a, s), y) => ((y::a), y::s) }
Stream(1,2,3,4,5).foldLeft( (List(): List[Int], Stream(): Stream[Int]) ){ case ((a, s), y) => ((y::a), y::s) }
Stream(1,2,3,4,5).foldLeft( (List(): List[Int], Stream(): Stream[Int]) ){ case ((a, s), y) => ((y::a), s.append(y)) }
Stream(1,2,3,4,5).foldLeft( (List(): List[Int], Stream(): Stream[Int]) ){ case ((a, s), y) => ((y::a), s.append(Stream(y))) }
Stream(1,2,3,4,5).foldLeft( (List(): List[Int], Stream(): Stream[Int]) ){ case ((a, s), y) => ((y::a).reverse, s.append(Stream(y))) }
Stream(1,2,3,4,5).foldLeft( (List(): List[Int], Stream(): Stream[Int]) ){ case ((a, s), y) => ((a::y), s.append(Stream(y))) }
Stream(1,2,3,4,5).foldLeft( (List(): List[Int], Stream(): Stream[Int]) ){ case ((a, s), y) => ((y::a), s.append(Stream(y))) }
List(1,2,3,4,5).tail
List(1,2,3,4,5).last
exit
stop
